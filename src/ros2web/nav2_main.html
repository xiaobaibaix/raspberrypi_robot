<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROS2D - åœ°å›¾ä¸é›·è¾¾æ˜¾ç¤º</title>
  
  <!-- ROS2D ç›¸å…³åº“ -->
  <script src="https://cdn.jsdelivr.net/npm/easeljs@1.0.2/lib/easeljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/eventemitter2@6.4.9/lib/eventemitter2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1.3.0/build/roslib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ros2d@0.10.0/build/ros2d.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      overflow: hidden;
      height: 100vh;
    }
    
    /* ä¸»å®¹å™¨ */
    .app-container {
      display: flex;
      height: 100vh;
      position: relative;
    }
    
    /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
    .control-panel {
      width: 350px;
      background-color: #fff;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      z-index: 1000;
      position: relative;
    }
    
    .control-panel.collapsed {
      width: 50px;
    }
    
    .control-panel.collapsed .panel-content {
      opacity: 0;
      visibility: hidden;
      height: 0;
      overflow: hidden;
    }
    
    .control-panel.collapsed .panel-header h2 {
      display: none;
    }
    
    /* é¢æ¿å¤´éƒ¨ */
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px 20px;
      background-color: #2c3e50;
      color: white;
    }
    
    .panel-header h2 {
      font-size: 18px;
      font-weight: 500;
      margin: 0;
    }
    
    .toggle-btn {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 5px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    
    .toggle-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* é¢æ¿å†…å®¹ */
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      transition: all 0.3s ease;
    }
    
    /* æ§åˆ¶ç»„æ ·å¼ */
    .control-group {
      margin-bottom: 25px;
    }
    
    .control-group:last-child {
      margin-bottom: 0;
    }
    
    .control-group h3 {
      font-size: 16px;
      color: #2c3e50;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eaeaea;
      font-weight: 500;
    }
    
    /* è¡¨å•æ§ä»¶ */
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      font-size: 13px;
      color: #555;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    .form-control {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      transition: border-color 0.2s;
    }
    
    .form-control:focus {
      outline: none;
      border-color: #3498db;
    }
    
    /* æŒ‰é’®ç»„ */
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    
    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .btn-primary {
      background-color: #3498db;
      color: white;
    }
    
    .btn-primary:hover:not(:disabled) {
      background-color: #2980b9;
    }
    
    .btn-success {
      background-color: #2ecc71;
      color: white;
    }
    
    .btn-success:hover:not(:disabled) {
      background-color: #27ae60;
    }
    
    .btn-danger {
      background-color: #e74c3c;
      color: white;
    }
    
    .btn-danger:hover:not(:disabled) {
      background-color: #c0392b;
    }
    
    .btn-secondary {
      background-color: #95a5a6;
      color: white;
    }
    
    .btn-secondary:hover:not(:disabled) {
      background-color: #7f8c8d;
    }
    
    .btn:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    
    /* è¯é¢˜ç›‘è§†å™¨å®¹å™¨ */
    .topic-monitor-container {
      margin-top: 20px;
    }
    
    .topic-monitor-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .topic-selector {
      flex: 1;
    }
    
    .topic-drawers {
      margin-top: 15px;
    }
    
    /* æŠ½å±‰æ ·å¼ */
    .drawer {
      background-color: #f8f9fa;
      border: 1px solid #eaeaea;
      border-radius: 6px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    
    .drawer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background-color: #f1f2f6;
      border-bottom: 1px solid #eaeaea;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .drawer-header:hover {
      background-color: #e8e9ed;
    }
    
    .drawer-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 500;
      color: #2c3e50;
    }
    
    .drawer-topic {
      font-family: 'Courier New', monospace;
      background-color: #e8e9ed;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
    }
    
    .drawer-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .drawer-toggle, .drawer-remove {
      background: none;
      border: none;
      color: #7f8c8d;
      cursor: pointer;
      font-size: 12px;
      padding: 4px;
      border-radius: 3px;
      transition: all 0.2s;
    }
    
    .drawer-toggle:hover, .drawer-remove:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }
    
    .drawer-content {
      padding: 15px;
      display: none;
    }
    
    .drawer-content.expanded {
      display: block;
    }
    
    .drawer-info {
      margin-bottom: 15px;
    }
    
    .drawer-info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .info-label {
      font-size: 12px;
      color: #7f8c8d;
    }
    
    .info-value {
      font-size: 12px;
      font-weight: 500;
      color: #2c3e50;
      font-family: 'Courier New', monospace;
    }
    
    .message-data {
      background-color: #fff;
      border: 1px solid #eaeaea;
      border-radius: 4px;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .message-empty {
      color: #95a5a6;
      font-style: italic;
      text-align: center;
      padding: 20px;
    }
    
    /* å¯è§†åŒ–æ§åˆ¶å¼€å…³ */
    .visualization-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
      padding: 8px 0;
      border-top: 1px solid #f0f0f0;
    }
    
    .vis-toggle-label {
      font-size: 12px;
      color: #7f8c8d;
    }
    
    .vis-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    
    .vis-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .vis-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    
    .vis-toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .vis-toggle-slider {
      background-color: #2ecc71;
    }
    
    input:checked + .vis-toggle-slider:before {
      transform: translateX(20px);
    }
    
    /* åœ°å›¾å®¹å™¨ */
    .map-container {
      flex: 1;
      position: relative;
      background-color: #ecf0f1;
      overflow: hidden;
    }
    
    #map {
      width: 100%;
      height: 100%;
    }
    
    /* çŠ¶æ€é¢æ¿ */
    .status-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 100;
      min-width: 250px;
    }
    
    .status-panel h3 {
      font-size: 16px;
      color: #2c3e50;
      margin-bottom: 10px;
      font-weight: 500;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 15px;
    }
    
    .status-item {
      display: flex;
      align-items: center;
    }
    
    .status-label {
      font-size: 13px;
      color: #7f8c8d;
      min-width: 60px;
    }
    
    .status-value {
      font-size: 13px;
      font-weight: 500;
    }
    
    .status-connected {
      color: #27ae60;
    }
    
    .status-disconnected {
      color: #e74c3c;
    }
    
    /* å›¾ä¾‹é¢æ¿ */
    .legend-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 100;
      min-width: 200px;
    }
    
    .legend-panel h3 {
      font-size: 16px;
      color: #2c3e50;
      margin-bottom: 10px;
      font-weight: 500;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 2px;
      margin-right: 10px;
    }
    
    .legend-label {
      font-size: 13px;
      color: #34495e;
    }
    
    /* æ—¥å¿—é¢æ¿ */
    .log-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.85);
      color: #ecf0f1;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 100;
      width: 400px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }
    
    .log-panel.visible {
      display: block;
    }
    
    .log-panel h3 {
      font-size: 16px;
      margin-bottom: 10px;
      color: #ecf0f1;
      font-weight: 500;
    }
    
    .log-entry {
      font-size: 12px;
      font-family: 'Courier New', monospace;
      margin-bottom: 5px;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .log-timestamp {
      color: #95a5a6;
      margin-right: 10px;
    }
    
    .log-message {
      color: #ecf0f1;
    }
    
    /* æ“ä½œæç¤º */
    .help-panel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(52, 152, 219, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 100;
      max-width: 300px;
    }
    
    .help-panel h3 {
      font-size: 16px;
      margin-bottom: 8px;
      font-weight: 500;
    }
    
    .help-tip {
      font-size: 13px;
      margin-bottom: 4px;
    }
    
    /* å¿«é€Ÿæ§åˆ¶æŒ‰é’® */
    .quick-controls {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    
    .quick-btn {
      padding: 8px 16px;
      background-color: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.2s;
    }
    
    .quick-btn:hover {
      background-color: white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    /* å…¨å±æ¨¡å¼ */
    .fullscreen-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: rgba(52, 152, 219, 0.9);
      color: white;
      border: none;
      cursor: pointer;
      font-size: 18px;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .fullscreen-btn:hover {
      background-color: #3498db;
    }
    
    /* æ¶ˆæ¯é€šçŸ¥ */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #2ecc71;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: space-between;
      min-width: 300px;
    }
    
    .notification.error {
      background-color: #e74c3c;
    }
    
    .notification.warning {
      background-color: #f39c12;
    }
    
    .notification.show {
      display: flex;
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    /* å“åº”å¼è°ƒæ•´ */
    @media (max-width: 1200px) {
      .control-panel:not(.collapsed) {
        width: 300px;
      }
      
      .log-panel {
        width: 350px;
      }
    }
    
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .control-panel:not(.collapsed) {
        width: 100%;
        height: 300px;
      }
      
      .control-panel.collapsed {
        width: 100%;
        height: 60px;
      }
      
      .panel-content {
        height: calc(100% - 60px);
      }
      
      .legend-panel, .help-panel {
        display: none;
      }
      
      .status-panel {
        left: 10px;
        bottom: 10px;
        padding: 10px 15px;
      }
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div class="control-panel" id="controlPanel">
      <div class="panel-header">
        <h2>ROS2è¿æ¥æ§åˆ¶</h2>
        <button class="toggle-btn" id="togglePanelBtn">
          <span id="toggleIcon">â—€</span>
        </button>
      </div>
      
      <div class="panel-content" id="panelContent">
        <!-- è¯é¢˜ç›‘è§†å™¨ -->
        <div class="control-group topic-monitor-container">
          <h3>è¯é¢˜ç›‘è§†</h3>
          <div class="topic-monitor-header">
            <select id="topicSelector" class="form-control topic-selector">
              <option value="">é€‰æ‹©è¯é¢˜...</option>
            </select>
            <button id="refreshTopicsBtn" class="btn btn-secondary" disabled>åˆ·æ–°</button>
            <button id="addTopicBtn" class="btn btn-primary" disabled>æ·»åŠ </button>
          </div>
          
          <div id="topicDrawers" class="topic-drawers">
            <!-- è¯é¢˜æŠ½å±‰å°†åœ¨è¿™é‡ŒåŠ¨æ€æ·»åŠ  -->
          </div>
        </div>
      </div>
    </div>
    
    <!-- åœ°å›¾å®¹å™¨ -->
    <div class="map-container">
      <div id="map"></div>
      
      <!-- çŠ¶æ€é¢æ¿ -->
      <div class="status-panel">
        <h3>ç³»ç»ŸçŠ¶æ€</h3>
        <div class="status-grid">
          <div class="status-item">
            <span class="status-label">ROSè¿æ¥:</span>
            <span id="rosStatus" class="status-value status-disconnected">æœªè¿æ¥</span>
          </div>
          <div class="status-item">
            <span class="status-label">è¯é¢˜æ•°é‡:</span>
            <span id="topicCount" class="status-value">0</span>
          </div>
          <div class="status-item">
            <span class="status-label">ç›‘è§†å™¨æ•°é‡:</span>
            <span id="monitorCount" class="status-value">0</span>
          </div>
          <div class="status-item">
            <span class="status-label">åœ°å›¾çŠ¶æ€:</span>
            <span id="mapStatus" class="status-value">æ— </span>
          </div>
        </div>
      </div>
      
      <!-- å›¾ä¾‹é¢æ¿ -->
      <div class="legend-panel">
        <h3>å›¾ä¾‹è¯´æ˜</h3>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #888;"></div>
          <span class="legend-label">æœªçŸ¥åŒºåŸŸ</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #fff; border: 1px solid #ddd;"></div>
          <span class="legend-label">ç©ºé—²åŒºåŸŸ</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #000;"></div>
          <span class="legend-label">éšœç¢ç‰©</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #f00;"></div>
          <span class="legend-label">é›·è¾¾ç‚¹äº‘</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #0f0; border: 1px solid #ddd;"></div>
          <span class="legend-label">æœºå™¨äººä½ç½®</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #00f;"></div>
          <span class="legend-label">å¯¼èˆªè·¯å¾„</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #ff0;"></div>
          <span class="legend-label">å±€éƒ¨åœ°å›¾</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #f0f;"></div>
          <span class="legend-label">å…¨å±€åœ°å›¾</span>
        </div>
      </div>
      
      <!-- æ—¥å¿—é¢æ¿ -->
      <div class="log-panel" id="logPanel">
        <h3>ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logContent"></div>
      </div>
      
      <!-- æ“ä½œæç¤º -->
      <div class="help-panel">
        <h3>æ“ä½œæç¤º</h3>
        <div class="help-tip">â€¢ é¼ æ ‡å·¦é”®æ‹–æ‹½åœ°å›¾</div>
        <div class="help-tip">â€¢ é¼ æ ‡æ»šè½®ç¼©æ”¾åœ°å›¾</div>
        <div class="help-tip">â€¢ åŒå‡»é‡ç½®è§†å›¾</div>
        <div class="help-tip">â€¢ å¿«æ·é”®: R=é‡ç½®, P=é¢æ¿</div>
      </div>
      
      <!-- å¿«é€Ÿæ§åˆ¶æŒ‰é’® -->
      <div class="quick-controls">
        <button class="quick-btn" id="toggleLogBtn">æ˜¾ç¤ºæ—¥å¿—</button>
        <button class="quick-btn" id="toggleHelpBtn">éšè—æç¤º</button>
        <button class="quick-btn" id="clearLogBtn">æ¸…ç©ºæ—¥å¿—</button>
      </div>
      
      <!-- å…¨å±æŒ‰é’® -->
      <button class="fullscreen-btn" id="fullscreenBtn">â›¶</button>
    </div>
    
    <!-- æ¶ˆæ¯é€šçŸ¥ -->
    <div class="notification" id="notification"></div>
  </div>

  <script>
    class ROS2DMapViewer {
      constructor() {
        this.viewer = null;
        this.ros = null;
        this.isConnected = false;
        this.autoConnect = true; // è‡ªåŠ¨è¿æ¥æ ‡å¿—
        
        // åœ°å›¾ä¿¡æ¯
        this.mapInfo = {
          width: 0,
          height: 0,
          resolution: 0.05,
          origin: { x: 0, y: 0, theta: 0 }
        };
        
        // è¯é¢˜ç›‘è§†å™¨
        this.monitoredTopics = new Map(); // topicName -> { subscription, drawerId, data, type, container, visualizationEnabled }
        this.drawerCounter = 0;
        
        // è¯é¢˜ç±»å‹ç¼“å­˜
        this.topicTypes = new Map();
        
        // åœºæ™¯å®¹å™¨
        this.scene = null;
        
        // å®¹å™¨Zè½´å±‚çº§ç®¡ç†
        this.containerLayers = {
          'map': 0,
          'path': 1,
          'lidar': 2,
          'robot': 3
        };
        
        // å½“å‰æ´»åŠ¨åœ°å›¾ï¼ˆç”¨äºåæ ‡è½¬æ¢å‚è€ƒï¼‰
        this.activeMapTopic = null;
        
        // åˆå§‹åŒ–
        this.init();
      }
      
      init() {
        this.initViewer();
        this.initUI();
        this.initEventListeners();
        this.logMessage("ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ", "info");
        
        // è‡ªåŠ¨è¿æ¥åˆ°æŒ‡å®šIPçš„ROS Bridge
        if (this.autoConnect) {
          setTimeout(() => {
            this.logMessage("å°è¯•è‡ªåŠ¨è¿æ¥åˆ°ROS Bridge...", "info");
            this.connectROS();
          }, 1000);
        }
      }
      
      // åˆå§‹åŒ–åœ°å›¾æŸ¥çœ‹å™¨
      initViewer() {
        try {
          this.viewer = new ROS2D.Viewer({
            divID: 'map',
            width: document.querySelector('.map-container').offsetWidth,
            height: document.querySelector('.map-container').offsetHeight
          });
          
          // å¯ç”¨é¼ æ ‡äº¤äº’
          this.viewer.scale = 1.0;
          
          // è·å–åœºæ™¯å¯¹è±¡
          this.scene = this.viewer.scene;
          
          this.logMessage("åœ°å›¾æŸ¥çœ‹å™¨åˆå§‹åŒ–æˆåŠŸ", "success");
        } catch (error) {
          this.logMessage(`åœ°å›¾æŸ¥çœ‹å™¨åˆå§‹åŒ–å¤±è´¥: ${error}`, "error");
        }
      }
      
      // åˆå§‹åŒ–UI
      initUI() {
        this.updateStatus('rosStatus', 'æœªè¿æ¥', 'disconnected');
        this.updateStatus('topicCount', '0');
        this.updateStatus('monitorCount', '0');
        this.updateStatus('mapStatus', 'æ— ');
      }
      
      // è¿æ¥ROS - ç›´æ¥è¿æ¥åˆ°æŒ‡å®šIP
      connectROS() {
        const url = "ws://192.168.0.111:9090"; // å›ºå®šçš„IPåœ°å€
        
        this.logMessage(`æ­£åœ¨è¿æ¥åˆ°ROS Bridge: ${url}`, "info");
        this.updateStatus('rosStatus', 'è¿æ¥ä¸­...');
        
        this.ros = new ROSLIB.Ros({
          url: url
        });
        
        this.ros.on('connection', () => {
          this.isConnected = true;
          this.updateStatus('rosStatus', 'å·²è¿æ¥', 'connected');
          document.getElementById('refreshTopicsBtn').disabled = false;
          document.getElementById('addTopicBtn').disabled = false;
          
          this.showNotification("æˆåŠŸè¿æ¥åˆ°ROS", "success");
          this.logMessage("ROSè¿æ¥æˆåŠŸ", "success");
          
          // è¿æ¥æˆåŠŸååˆ·æ–°è¯é¢˜åˆ—è¡¨
          setTimeout(() => {
            this.refreshTopicList();
          }, 500);
        });
        
        this.ros.on('error', (error) => {
          this.logMessage(`è¿æ¥é”™è¯¯: ${error}`, "error");
          this.updateStatus('rosStatus', 'è¿æ¥å¤±è´¥', 'disconnected');
          this.showNotification("è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ROS Bridgeæ˜¯å¦è¿è¡Œ", "error");
        });
        
        this.ros.on('close', () => {
          this.isConnected = false;
          this.updateStatus('rosStatus', 'æœªè¿æ¥', 'disconnected');
          document.getElementById('refreshTopicsBtn').disabled = true;
          document.getElementById('addTopicBtn').disabled = true;
          
          // æ¸…ç©ºè¯é¢˜åˆ—è¡¨
          this.clearTopicList();
          
          // ç§»é™¤æ‰€æœ‰è¯é¢˜ç›‘è§†å™¨
          this.removeAllMonitoredTopics();
          
          this.logMessage("ROSè¿æ¥å·²å…³é—­", "warning");
        });
      }
      
      // æ–­å¼€ROSè¿æ¥
      disconnectROS() {
        if (this.ros) {
          this.removeAllMonitoredTopics();
          this.ros.close();
          this.ros = null;
        }
      }
      
      // åˆ·æ–°è¯é¢˜åˆ—è¡¨ - ä½¿ç”¨ros.getTopics()æ–¹æ³•
      refreshTopicList() {
        if (!this.isConnected || !this.ros) {
          this.showNotification("æœªè¿æ¥åˆ°ROS", "warning");
          return;
        }
        
        this.logMessage("è·å–è¯é¢˜åˆ—è¡¨ä¸­...", "info");
        
        // ä½¿ç”¨ros.getTopics()æ–¹æ³•è·å–è¯é¢˜åˆ—è¡¨
        this.ros.getTopics(
          (result) => {
            // æˆåŠŸå›è°ƒ
            if (result && result.topics && result.types) {
              // å¤„ç†è·å–åˆ°çš„è¯é¢˜åˆ—è¡¨
              const topics = result.topics.map((name, index) => ({
                name,
                type: result.types[index] || 'æœªçŸ¥ç±»å‹'
              }));
              
              this.updateTopicSelector(topics);
              this.showNotification(`å‘ç° ${topics.length} ä¸ªè¯é¢˜`, "success");
            } else {
              this.logMessage("è·å–çš„è¯é¢˜åˆ—è¡¨æ ¼å¼ä¸æ­£ç¡®", "warning");
              this.showNotification("è·å–è¯é¢˜åˆ—è¡¨å¤±è´¥ï¼Œå°è¯•å›é€€åˆ°å¸¸è§è¯é¢˜", "warning");
              this.fallbackToCommonTopics();
            }
          },
          (error) => {
            // é”™è¯¯å›è°ƒ
            this.logMessage(`è·å–è¯é¢˜åˆ—è¡¨å¤±è´¥: ${error}`, "error");
            this.showNotification("è·å–è¯é¢˜åˆ—è¡¨å¤±è´¥ï¼Œå°è¯•å›é€€åˆ°å¸¸è§è¯é¢˜", "warning");
            
            // å›é€€åˆ°å¸¸è§è¯é¢˜åˆ—è¡¨
            this.fallbackToCommonTopics();
          }
        );
      }
      
      // å›é€€åˆ°å¸¸è§è¯é¢˜åˆ—è¡¨
      fallbackToCommonTopics() {
        const commonTopics = [
          '/map',
          '/scan',
          '/odom',
          '/amcl_pose',
          '/move_base_simple/goal',
          '/initialpose',
          '/cmd_vel',
          '/global_plan',
          '/local_plan',
          '/path',
          '/rosout',
          '/tf',
          '/tf_static',
          '/diagnostics',
          '/global_costmap/costmap',
          '/local_costmap/costmap'
        ];
        
        this.updateTopicSelector(commonTopics);
      }
      
      // æ›´æ–°è¯é¢˜é€‰æ‹©å™¨
      updateTopicSelector(topics) {
        const topicSelector = document.getElementById('topicSelector');
        topicSelector.innerHTML = '<option value="">é€‰æ‹©è¯é¢˜...</option>';
        
        if (topics && topics.length > 0) {
          // æŒ‰è¯é¢˜åç§°æ’åº
          const sortedTopics = topics.sort((a, b) => {
            if (typeof a === 'string') {
              return a.localeCompare(b);
            } else if (a.name) {
              return a.name.localeCompare(b.name);
            }
            return 0;
          });
          
          // æ·»åŠ åˆ°ä¸‹æ‹‰åˆ—è¡¨
          sortedTopics.forEach((topic) => {
            let topicName, topicType;
            
            if (typeof topic === 'string') {
              topicName = topic;
              topicType = this.topicTypes.get(topic) || 'æœªçŸ¥ç±»å‹';
            } else {
              topicName = topic.name;
              topicType = topic.type || this.topicTypes.get(topicName) || 'æœªçŸ¥ç±»å‹';
              // æ›´æ–°è¯é¢˜ç±»å‹ç¼“å­˜
              this.topicTypes.set(topicName, topicType);
            }
            
            const option = document.createElement('option');
            option.value = topicName;
            option.textContent = `${topicName} (${topicType})`;
            option.dataset.type = topicType;
            topicSelector.appendChild(option);
          });
          
          this.updateStatus('topicCount', topics.length.toString());
          this.logMessage(`å‘ç° ${topics.length} ä¸ªè¯é¢˜`, "success");
        } else {
          this.logMessage("æœªæ‰¾åˆ°å¯ç”¨è¯é¢˜", "warning");
          this.showNotification("æœªæ‰¾åˆ°å¯ç”¨è¯é¢˜", "warning");
        }
      }
      
      // æ¸…ç©ºè¯é¢˜åˆ—è¡¨
      clearTopicList() {
        const topicSelector = document.getElementById('topicSelector');
        topicSelector.innerHTML = '<option value="">é€‰æ‹©è¯é¢˜...</option>';
        this.updateStatus('topicCount', '0');
        this.topicTypes.clear();
      }
      
      // æ·»åŠ è¯é¢˜ç›‘è§†å™¨
      addTopicMonitor() {
        const topicSelector = document.getElementById('topicSelector');
        const selectedTopic = topicSelector.value;
        
        if (!selectedTopic) {
          this.showNotification("è¯·é€‰æ‹©ä¸€ä¸ªè¯é¢˜", "warning");
          return;
        }
        
        if (this.monitoredTopics.has(selectedTopic)) {
          this.showNotification("è¯¥è¯é¢˜å·²åœ¨ç›‘è§†åˆ—è¡¨ä¸­", "warning");
          return;
        }
        
        const selectedOption = topicSelector.options[topicSelector.selectedIndex];
        let topicType = selectedOption.dataset.type;
        
        // å¦‚æœç±»å‹æ˜¯"æœªçŸ¥ç±»å‹"ï¼Œå°è¯•è·å–çœŸå®ç±»å‹
        if (!topicType || topicType === 'æœªçŸ¥ç±»å‹') {
          this.getTopicType(selectedTopic).then(type => {
            if (type && type !== 'æœªçŸ¥ç±»å‹') {
              this.topicTypes.set(selectedTopic, type);
              this.createTopicMonitor(selectedTopic, type);
            } else {
              // å¦‚æœæ— æ³•è·å–ç±»å‹ï¼Œä½¿ç”¨é»˜è®¤ç±»å‹å°è¯•
              this.createTopicMonitor(selectedTopic, this.guessTopicType(selectedTopic));
            }
          }).catch(() => {
            // å¦‚æœè·å–ç±»å‹å¤±è´¥ï¼Œä½¿ç”¨çŒœæµ‹çš„ç±»å‹
            this.createTopicMonitor(selectedTopic, this.guessTopicType(selectedTopic));
          });
        } else {
          this.createTopicMonitor(selectedTopic, topicType);
        }
      }
      
      // è·å–è¯é¢˜ç±»å‹
      getTopicType(topicName) {
        return new Promise((resolve, reject) => {
          // å°è¯•é€šè¿‡ getTopicType æ–¹æ³•è·å–è¯é¢˜ç±»å‹
          const getTopicTypeClient = new ROSLIB.Service({
            ros: this.ros,
            name: '/rosapi/get_topic_type',
            serviceType: 'rosapi/GetTopicType'
          });
          
          const request = new ROSLIB.ServiceRequest({
            topic: topicName
          });
          
          getTopicTypeClient.callService(request, (response) => {
            if (response && response.type) {
              resolve(response.type);
            } else {
              reject(new Error('No type returned'));
            }
          }, (error) => {
            // å¦‚æœæœåŠ¡ä¸å­˜åœ¨ï¼Œä½¿ç”¨çŒœæµ‹çš„ç±»å‹
            const guessedType = this.guessTopicType(topicName);
            resolve(guessedType);
          });
        });
      }
      
      // åˆ›å»ºè¯é¢˜ç›‘è§†å™¨
      createTopicMonitor(topicName, topicType) {
        this.logMessage(`å¼€å§‹ç›‘è§†è¯é¢˜: ${topicName} (ç±»å‹: ${topicType})`, "info");
        
        // åˆ›å»ºè¯é¢˜è®¢é˜…
        const subscription = new ROSLIB.Topic({
          ros: this.ros,
          name: topicName,
          messageType: topicType
        });
        
        const drawerId = `drawer-${++this.drawerCounter}`;
        
        // åˆ¤æ–­æ˜¯å¦éœ€è¦å¯è§†åŒ–
        const shouldVisualize = this.shouldVisualizeTopic(topicName, topicType);
        
        // åˆ›å»ºæŠ½å±‰UI
        this.createTopicDrawer(topicName, topicType, drawerId, shouldVisualize);
        
        // å¦‚æœéœ€è¦å¯è§†åŒ–ï¼Œåˆ›å»ºå®¹å™¨
        let container = null;
        if (shouldVisualize) {
          container = this.createVisualizationContainer(topicName, topicType);
        }
        
        // è®¢é˜…è¯é¢˜
        const startTime = Date.now();
        let messageCount = 0;
        let lastMessageTime = startTime;
        
        subscription.subscribe((message) => {
          messageCount++;
          const currentTime = Date.now();
          const timeSinceLastMessage = currentTime - lastMessageTime;
          lastMessageTime = currentTime;
          
          // æ›´æ–°æŠ½å±‰å†…å®¹
          this.updateTopicDrawer(drawerId, topicName, message, messageCount, startTime, timeSinceLastMessage);
          
          // å¦‚æœå¯ç”¨äº†å¯è§†åŒ–ï¼Œå¤„ç†æ¶ˆæ¯ç”¨äºå¯è§†åŒ–
          const monitor = this.monitoredTopics.get(topicName);
          if (monitor && monitor.visualizationEnabled && container) {
            this.processMessageForVisualization(topicName, topicType, message, container);
          }
        });
        
        // ä¿å­˜è®¢é˜…ä¿¡æ¯
        this.monitoredTopics.set(topicName, {
          subscription: subscription,
          drawerId: drawerId,
          messageCount: 0,
          startTime: startTime,
          lastMessage: null,
          topicType: topicType,
          container: container,
          visualizationEnabled: shouldVisualize
        });
        
        // æ›´æ–°ç›‘è§†å™¨æ•°é‡
        this.updateStatus('monitorCount', this.monitoredTopics.size.toString());
        
        this.showNotification(`å·²å¼€å§‹ç›‘è§†è¯é¢˜: ${topicName}`, "success");
      }
      
      // åˆ¤æ–­è¯é¢˜æ˜¯å¦éœ€è¦å¯è§†åŒ–
      shouldVisualizeTopic(topicName, topicType) {
        // åªå¯¹ç‰¹å®šç±»å‹çš„è¯é¢˜è¿›è¡Œå¯è§†åŒ–
        if (topicType === 'nav_msgs/msg/OccupancyGrid' || topicName.includes('map') || topicName.includes('costmap')) {
          return true;
        } else if (topicType === 'sensor_msgs/msg/LaserScan' || topicName.includes('scan')) {
          return true;
        } else if (topicType === 'nav_msgs/msg/Path' || topicName.includes('path') || topicName.includes('plan')) {
          return true;
        } else if (topicType === 'geometry_msgs/msg/PoseWithCovarianceStamped' || 
                  topicType === 'geometry_msgs/msg/PoseStamped' || 
                  topicName.includes('pose') || 
                  topicName.includes('odom')) {
          return true;
        }
        return false;
      }
      
      // åˆ›å»ºå¯è§†åŒ–å®¹å™¨
      createVisualizationContainer(topicName, topicType) {
        const container = new createjs.Container();
        
        // è®¾ç½®å®¹å™¨å±‚çº§
        let layer = 0;
        if (topicType === 'nav_msgs/msg/OccupancyGrid' || topicName.includes('map') || topicName.includes('costmap')) {
          layer = this.containerLayers.map;
        } else if (topicType === 'sensor_msgs/msg/LaserScan' || topicName.includes('scan')) {
          layer = this.containerLayers.lidar;
        } else if (topicType === 'nav_msgs/msg/Path' || topicName.includes('path') || topicName.includes('plan')) {
          layer = this.containerLayers.path;
        } else if (topicType === 'geometry_msgs/msg/PoseWithCovarianceStamped' || 
                  topicType === 'geometry_msgs/msg/PoseStamped' || 
                  topicName.includes('pose') || 
                  topicName.includes('odom')) {
          layer = this.containerLayers.robot;
        }
        
        container.layer = layer;
        container.name = topicName;
        
        // å°†å®¹å™¨æ·»åŠ åˆ°åœºæ™¯
        this.scene.addChild(container);
        
        // é‡æ–°æ’åºå®¹å™¨ä»¥ç¡®ä¿æ­£ç¡®çš„Zè½´é¡ºåº
        this.sortContainersByLayer();
        
        return container;
      }
      
      // æŒ‰å±‚çº§æ’åºå®¹å™¨
      sortContainersByLayer() {
        // æ”¶é›†æ‰€æœ‰å®¹å™¨
        const containers = [];
        for (let i = 0; i < this.scene.children.length; i++) {
          const child = this.scene.children[i];
          if (child.layer !== undefined) {
            containers.push(child);
          }
        }
        
        // æŒ‰å±‚çº§æ’åº
        containers.sort((a, b) => a.layer - b.layer);
        
        // é‡æ–°æ·»åŠ åˆ°åœºæ™¯
        containers.forEach((container, index) => {
          this.scene.setChildIndex(container, index);
        });
      }
      
      // åˆ‡æ¢è¯é¢˜å¯è§†åŒ–
      toggleTopicVisualization(topicName) {
        const monitor = this.monitoredTopics.get(topicName);
        if (monitor) {
          monitor.visualizationEnabled = !monitor.visualizationEnabled;
          
          if (monitor.container) {
            monitor.container.visible = monitor.visualizationEnabled;
          }
          
          this.logMessage(`${monitor.visualizationEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}è¯é¢˜ ${topicName} çš„å¯è§†åŒ–`, "info");
          return monitor.visualizationEnabled;
        }
        return false;
      }
      
      // çŒœæµ‹è¯é¢˜ç±»å‹
      guessTopicType(topicName) {
        // æ ¹æ®è¯é¢˜åç§°çŒœæµ‹ç±»å‹
        if (topicName.includes('map') || topicName.includes('costmap')) {
          return 'nav_msgs/msg/OccupancyGrid';
        } else if (topicName.includes('scan')) {
          return 'sensor_msgs/msg/LaserScan';
        } else if (topicName.includes('pose') || topicName.includes('odom')) {
          return 'geometry_msgs/msg/PoseWithCovarianceStamped';
        } else if (topicName.includes('path') || topicName.includes('plan')) {
          return 'nav_msgs/msg/Path';
        } else if (topicName.includes('cmd_vel')) {
          return 'geometry_msgs/msg/Twist';
        } else if (topicName.includes('goal') || topicName.includes('initialpose')) {
          return 'geometry_msgs/msg/PoseStamped';
        } else if (topicName.includes('tf')) {
          return 'tf2_msgs/msg/TFMessage';
        } else if (topicName.includes('diagnostics')) {
          return 'diagnostic_msgs/msg/DiagnosticArray';
        } else if (topicName.includes('rosout')) {
          return 'rcl_interfaces/msg/Log';
        } else {
          return 'std_msgs/msg/String'; // é»˜è®¤ç±»å‹
        }
      }
      
      // å¤„ç†æ¶ˆæ¯ç”¨äºå¯è§†åŒ–
      processMessageForVisualization(topicName, topicType, message, container) {
        // æ¸…é™¤å®¹å™¨ä¸­çš„æ—§å†…å®¹
        container.removeAllChildren();
        
        // å¤„ç†åœ°å›¾è¯é¢˜
        if (topicType === 'nav_msgs/msg/OccupancyGrid' || topicName.includes('map') || topicName.includes('costmap')) {
          this.processMapMessage(message, container, topicName);
        }
        // å¤„ç†é›·è¾¾è¯é¢˜
        else if (topicType === 'sensor_msgs/msg/LaserScan' || topicName.includes('scan')) {
          this.processLidarMessage(message, container, topicName);
        }
        // å¤„ç†è·¯å¾„è¯é¢˜
        else if (topicType === 'nav_msgs/msg/Path' || topicName.includes('path') || topicName.includes('plan')) {
          this.processPathMessage(message, container, topicName);
        }
        // å¤„ç†ä½å§¿è¯é¢˜
        else if (topicType === 'geometry_msgs/msg/PoseWithCovarianceStamped' || 
                topicType === 'geometry_msgs/msg/PoseStamped' || 
                topicName.includes('pose') || 
                topicName.includes('odom')) {
          this.processPoseMessage(message, container, topicName);
        }
        // å…¶ä»–ç±»å‹çš„è¯é¢˜ä¸è¿›è¡Œå¯è§†åŒ–
      }
      
      // å¤„ç†åœ°å›¾æ¶ˆæ¯
      processMapMessage(mapMsg, container, topicName) {
        // ä¿å­˜åœ°å›¾ä¿¡æ¯
        this.mapInfo = {
          width: mapMsg.info.width,
          height: mapMsg.info.height,
          resolution: mapMsg.info.resolution,
          origin: {
            x: mapMsg.info.origin.position.x,
            y: mapMsg.info.origin.position.y,
            theta: 0
          }
        };
        
        // è®¾ç½®å½“å‰æ´»åŠ¨åœ°å›¾
        this.activeMapTopic = topicName;
        this.updateStatus('mapStatus', 'å·²åŠ è½½');
        this.logMessage(`åœ°å›¾åŠ è½½: ${this.mapInfo.width}x${this.mapInfo.height}, åˆ†è¾¨ç‡: ${this.mapInfo.resolution}`, "success");
        
        // åˆ›å»ºåœ°å›¾æ˜¾ç¤º
        const mapImage = new ROS2D.OccupancyGrid({
          ros: this.ros,
          rootObject: container,
          continuous: false
        });
        
        // æ‰‹åŠ¨è§¦å‘åœ°å›¾æ˜¾ç¤º
        mapImage.grid = mapMsg;
        mapImage.update();
        
        // è°ƒæ•´è§†å›¾ä»¥é€‚åº”åœ°å›¾
        this.viewer.scaleToDimensions(this.mapInfo.width, this.mapInfo.height);
        this.viewer.shift(this.mapInfo.origin.x, this.mapInfo.origin.y);
        
        this.showNotification("åœ°å›¾åŠ è½½æˆåŠŸ", "success");
      }
      
      // å¤„ç†é›·è¾¾æ¶ˆæ¯
      processLidarMessage(scanMsg, container, topicName) {
        if (!scanMsg.ranges || scanMsg.ranges.length === 0) return;
        
        const ranges = scanMsg.ranges;
        const angleMin = scanMsg.angle_min;
        const angleIncrement = scanMsg.angle_increment;
        
        // åˆ›å»ºé›·è¾¾ç‚¹å›¾å½¢
        const points = new createjs.Shape();
        const g = points.graphics;
        
        // æ ¹æ®è¯é¢˜åç§°è®¾ç½®é¢œè‰²
        let color = createjs.Graphics.getRGB(255, 0, 0, 0.7); // é»˜è®¤çº¢è‰²
        if (topicName.includes('front')) {
          color = createjs.Graphics.getRGB(255, 0, 0, 0.7); // å‰é›·è¾¾ç”¨çº¢è‰²
        } else if (topicName.includes('rear') || topicName.includes('back')) {
          color = createjs.Graphics.getRGB(255, 165, 0, 0.7); // åé›·è¾¾ç”¨æ©™è‰²
        } else if (topicName.includes('side')) {
          color = createjs.Graphics.getRGB(255, 255, 0, 0.7); // ä¾§é›·è¾¾ç”¨é»„è‰²
        }
        
        g.beginFill(color);
        
        // è®¡ç®—æ¯ä¸ªé›·è¾¾ç‚¹åœ¨åœ°å›¾åæ ‡ç³»ä¸­çš„ä½ç½®
        for (let i = 0; i < ranges.length; i++) {
          const range = ranges[i];
          
          // è·³è¿‡æ— æ•ˆç‚¹
          if (!isFinite(range) || range <= 0 || range > scanMsg.range_max) {
            continue;
          }
          
          const angle = angleMin + i * angleIncrement;
          
          // è½¬æ¢åˆ°åƒç´ åæ ‡
          const pixelsPerMeter = 1 / this.mapInfo.resolution;
          const localX = Math.cos(angle) * range * pixelsPerMeter;
          const localY = Math.sin(angle) * range * pixelsPerMeter;
          
          // è€ƒè™‘åœ°å›¾åŸç‚¹åç§»
          const finalX = localX - (this.mapInfo.origin.x * pixelsPerMeter);
          const finalY = localY - (this.mapInfo.origin.y * pixelsPerMeter);
          
          // ç»˜åˆ¶ç‚¹
          g.drawCircle(finalX, finalY, 2);
        }
        
        g.endFill();
        container.addChild(points);
      }
      
      // å¤„ç†è·¯å¾„æ¶ˆæ¯
      processPathMessage(pathMsg, container, topicName) {
        if (!pathMsg.poses || pathMsg.poses.length === 0) return;
        
        // åˆ›å»ºè·¯å¾„å›¾å½¢
        const path = new createjs.Shape();
        const g = path.graphics;
        
        // æ ¹æ®è¯é¢˜åç§°è®¾ç½®é¢œè‰²
        let color = createjs.Graphics.getRGB(0, 0, 255, 0.8); // é»˜è®¤è“è‰²
        if (topicName.includes('global') || topicName.includes('global_plan')) {
          color = createjs.Graphics.getRGB(0, 0, 255, 0.8); // å…¨å±€è·¯å¾„ç”¨è“è‰²
        } else if (topicName.includes('local') || topicName.includes('local_plan')) {
          color = createjs.Graphics.getRGB(0, 255, 255, 0.8); // å±€éƒ¨è·¯å¾„ç”¨é’è‰²
        }
        
        g.setStrokeStyle(2)
         .beginStroke(color)
         .moveTo(0, 0);
        
        const pixelsPerMeter = 1 / this.mapInfo.resolution;
        
        // ç»˜åˆ¶è·¯å¾„ç‚¹
        pathMsg.poses.forEach((pose, index) => {
          const x = pose.pose.position.x * pixelsPerMeter - (this.mapInfo.origin.x * pixelsPerMeter);
          const y = pose.pose.position.y * pixelsPerMeter - (this.mapInfo.origin.y * pixelsPerMeter);
          
          if (index === 0) {
            g.moveTo(x, y);
          } else {
            g.lineTo(x, y);
          }
          
          // åœ¨è·¯å¾„ç‚¹ä¸Šç»˜åˆ¶å°åœ†ç‚¹
          if (index % 5 === 0) {
            const dot = new createjs.Shape();
            dot.graphics.beginFill(color).drawCircle(x, y, 3);
            container.addChild(dot);
          }
        });
        
        g.endStroke();
        container.addChild(path);
      }
      
      // å¤„ç†ä½å§¿æ¶ˆæ¯
      processPoseMessage(poseMsg, container, topicName) {
        let pose;
        if (poseMsg.pose && poseMsg.pose.pose) {
          pose = poseMsg.pose.pose; // PoseWithCovarianceStamped
        } else if (poseMsg.pose) {
          pose = poseMsg.pose; // PoseStamped
        } else {
          return;
        }
        
        // è½¬æ¢åˆ°åƒç´ åæ ‡
        const pixelsPerMeter = 1 / this.mapInfo.resolution;
        const robotX = pose.position.x * pixelsPerMeter - (this.mapInfo.origin.x * pixelsPerMeter);
        const robotY = pose.position.y * pixelsPerMeter - (this.mapInfo.origin.y * pixelsPerMeter);
        
        // ä»å››å…ƒæ•°è®¡ç®—åèˆªè§’
        const q = pose.orientation;
        const theta = Math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y * q.y + q.z * q.z));
        
        // æ ¹æ®è¯é¢˜åç§°è®¾ç½®é¢œè‰²
        let color = "#00FF00"; // é»˜è®¤ç»¿è‰²
        if (topicName.includes('amcl')) {
          color = "#00FF00"; // AMCLä½å§¿ç”¨ç»¿è‰²
        } else if (topicName.includes('odom')) {
          color = "#FF00FF"; // é‡Œç¨‹è®¡ä½å§¿ç”¨ç´«è‰²
        } else if (topicName.includes('ground_truth')) {
          color = "#FFFF00"; // çœŸå®ä½å§¿ç”¨é»„è‰²
        }
        
        // åˆ›å»ºæœºå™¨äººæ ‡è®°
        const robot = new createjs.Shape();
        robot.graphics
          .setStrokeStyle(2)
          .beginStroke(color)
          .drawCircle(robotX, robotY, 10)
          .moveTo(robotX, robotY)
          .lineTo(robotX + Math.cos(theta) * 20, robotY + Math.sin(theta) * 20);
        
        // æ·»åŠ è¯é¢˜åç§°æ ‡ç­¾
        const label = new createjs.Text(this.getShortTopicName(topicName), "12px Arial", "#000");
        label.x = robotX + 15;
        label.y = robotY - 15;
        label.textBaseline = "alphabetic";
        
        container.addChild(robot);
        container.addChild(label);
      }
      
      // è·å–ç®€çŸ­çš„è¯é¢˜åç§°
      getShortTopicName(topicName) {
        const parts = topicName.split('/');
        return parts[parts.length - 1] || topicName;
      }
      
      // åˆ›å»ºè¯é¢˜æŠ½å±‰
      createTopicDrawer(topicName, topicType, drawerId, shouldVisualize) {
        const topicDrawers = document.getElementById('topicDrawers');
        
        const drawer = document.createElement('div');
        drawer.className = 'drawer';
        drawer.id = drawerId;
        
        let visualizationControl = '';
        if (shouldVisualize) {
          visualizationControl = `
            <div class="visualization-control">
              <span class="vis-toggle-label">å¯è§†åŒ–æ˜¾ç¤º</span>
              <label class="vis-toggle">
                <input type="checkbox" checked data-topic="${topicName}">
                <span class="vis-toggle-slider"></span>
              </label>
            </div>
          `;
        }
        
        drawer.innerHTML = `
          <div class="drawer-header">
            <div class="drawer-title">
              <span>ğŸ“¡</span>
              <span>è¯é¢˜ç›‘è§†</span>
              <span class="drawer-topic">${this.truncateText(topicName, 30)}</span>
            </div>
            <div class="drawer-controls">
              <button class="drawer-toggle" data-drawer="${drawerId}">å±•å¼€</button>
              <button class="drawer-remove" data-drawer="${drawerId}">Ã—</button>
            </div>
          </div>
          <div class="drawer-content" id="${drawerId}-content">
            <div class="drawer-info">
              <div class="drawer-info-item">
                <span class="info-label">è¯é¢˜åç§°:</span>
                <span class="info-value" id="${drawerId}-name">${topicName}</span>
              </div>
              <div class="drawer-info-item">
                <span class="info-label">æ¶ˆæ¯ç±»å‹:</span>
                <span class="info-value" id="${drawerId}-type">${topicType}</span>
              </div>
              <div class="drawer-info-item">
                <span class="info-label">æ¶ˆæ¯é¢‘ç‡:</span>
                <span class="info-value" id="${drawerId}-frequency">0 Hz</span>
              </div>
              <div class="drawer-info-item">
                <span class="info-label">æ¶ˆæ¯æ•°é‡:</span>
                <span class="info-value" id="${drawerId}-count">0</span>
              </div>
              <div class="drawer-info-item">
                <span class="info-label">æœ€åé—´éš”:</span>
                <span class="info-value" id="${drawerId}-interval">0 ms</span>
              </div>
            </div>
            ${visualizationControl}
            <div class="message-data" id="${drawerId}-data">
              <div class="message-empty">ç­‰å¾…æ¶ˆæ¯...</div>
            </div>
          </div>
        `;
        
        // æ·»åŠ åˆ°é¡¶éƒ¨
        topicDrawers.insertBefore(drawer, topicDrawers.firstChild);
        
        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        const toggleBtn = drawer.querySelector('.drawer-toggle');
        const removeBtn = drawer.querySelector('.drawer-remove');
        
        toggleBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggleDrawer(drawerId);
        });
        
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.removeTopicMonitor(topicName);
        });
        
        // ç‚¹å‡»å¤´éƒ¨ä¹Ÿå¯ä»¥åˆ‡æ¢
        const drawerHeader = drawer.querySelector('.drawer-header');
        drawerHeader.addEventListener('click', (e) => {
          if (e.target !== toggleBtn && e.target !== removeBtn) {
            this.toggleDrawer(drawerId);
          }
        });
        
        // æ·»åŠ å¯è§†åŒ–åˆ‡æ¢ç›‘å¬
        if (shouldVisualize) {
          const visToggle = drawer.querySelector('.vis-toggle input');
          visToggle.addEventListener('change', (e) => {
            const enabled = this.toggleTopicVisualization(topicName);
            e.target.checked = enabled;
          });
        }
      }
      
      // æ›´æ–°è¯é¢˜æŠ½å±‰
      updateTopicDrawer(drawerId, topicName, message, messageCount, startTime, timeSinceLastMessage) {
        const drawer = this.monitoredTopics.get(topicName);
        if (!drawer) return;
        
        drawer.messageCount = messageCount;
        drawer.lastMessage = message;
        
        // è®¡ç®—æ¶ˆæ¯é¢‘ç‡
        const elapsedTime = (Date.now() - startTime) / 1000; // ç§’
        const frequency = elapsedTime > 0 ? (messageCount / elapsedTime).toFixed(2) : "0";
        
        // æ›´æ–°UI
        const frequencyElement = document.getElementById(`${drawerId}-frequency`);
        const countElement = document.getElementById(`${drawerId}-count`);
        const intervalElement = document.getElementById(`${drawerId}-interval`);
        const dataElement = document.getElementById(`${drawerId}-data`);
        
        if (frequencyElement) frequencyElement.textContent = `${frequency} Hz`;
        if (countElement) countElement.textContent = messageCount;
        if (intervalElement && timeSinceLastMessage) {
          intervalElement.textContent = `${timeSinceLastMessage} ms`;
        }
        
        // æ˜¾ç¤ºæ¶ˆæ¯å†…å®¹æ‘˜è¦
        if (dataElement) {
          let messageContent = '';
          try {
            // åˆ›å»ºæ¶ˆæ¯æ‘˜è¦
            const messageSummary = this.createMessageSummary(message, drawer.topicType);
            messageContent = JSON.stringify(messageSummary, null, 2);
          } catch (e) {
            messageContent = 'æ— æ³•è§£ææ¶ˆæ¯å†…å®¹';
          }
          
          dataElement.innerHTML = `<pre style="margin: 0; font-size: 11px; white-space: pre-wrap; word-wrap: break-word;">${this.escapeHtml(messageContent)}</pre>`;
        }
        
        // æ›´æ–°æŠ½å±‰ä¸­çš„æ´»è·ƒçŠ¶æ€æŒ‡ç¤ºå™¨
        const drawerElement = document.getElementById(drawerId);
        if (drawerElement) {
          const titleElement = drawerElement.querySelector('.drawer-title span:first-child');
          if (titleElement) {
            titleElement.textContent = 'ğŸ”´'; // æ´»è·ƒçŠ¶æ€
            // 1ç§’åæ¢å¤
            setTimeout(() => {
              if (titleElement && this.monitoredTopics.has(topicName)) {
                titleElement.textContent = 'ğŸ“¡';
              }
            }, 1000);
          }
        }
      }
      
      // åˆ›å»ºæ¶ˆæ¯æ‘˜è¦
      createMessageSummary(message, topicType) {
        const summary = {
          timestamp: new Date().toISOString(),
          type: topicType
        };
        
        // æ ¹æ®æ¶ˆæ¯ç±»å‹åˆ›å»ºä¸åŒçš„æ‘˜è¦
        if (topicType === 'nav_msgs/msg/OccupancyGrid') {
          summary.width = message.info.width;
          summary.height = message.info.height;
          summary.resolution = message.info.resolution;
          summary.data_length = message.data.length;
        } else if (topicType === 'sensor_msgs/msg/LaserScan') {
          summary.ranges_length = message.ranges.length;
          summary.angle_min = message.angle_min;
          summary.angle_max = message.angle_max;
          summary.range_min = message.range_min;
          summary.range_max = message.range_max;
        } else if (topicType === 'nav_msgs/msg/Path') {
          summary.poses_length = message.poses.length;
          summary.frame_id = message.header.frame_id;
        } else if (topicType === 'geometry_msgs/msg/PoseWithCovarianceStamped' || 
                  topicType === 'geometry_msgs/msg/PoseStamped') {
          summary.position = {
            x: (message.pose && message.pose.pose) ? message.pose.pose.position.x : 
               (message.pose ? message.pose.position.x : 0),
            y: (message.pose && message.pose.pose) ? message.pose.pose.position.y : 
               (message.pose ? message.pose.position.y : 0),
            z: (message.pose && message.pose.pose) ? message.pose.pose.position.z : 
               (message.pose ? message.pose.position.z : 0)
          };
          summary.frame_id = message.header.frame_id;
        } else {
          // å¯¹äºå…¶ä»–ç±»å‹ï¼Œåªæ˜¾ç¤ºå‰5ä¸ªå±æ€§
          const keys = Object.keys(message).slice(0, 5);
          keys.forEach(key => {
            if (typeof message[key] === 'object') {
              summary[key] = 'object';
            } else {
              summary[key] = message[key];
            }
          });
        }
        
        return summary;
      }
      
      // åˆ‡æ¢æŠ½å±‰å±•å¼€/æ”¶èµ·
      toggleDrawer(drawerId) {
        const content = document.getElementById(`${drawerId}-content`);
        const toggleBtn = document.querySelector(`[data-drawer="${drawerId}"].drawer-toggle`);
        
        if (content && toggleBtn) {
          content.classList.toggle('expanded');
          toggleBtn.textContent = content.classList.contains('expanded') ? 'æ”¶èµ·' : 'å±•å¼€';
        }
      }
      
      // ç§»é™¤è¯é¢˜ç›‘è§†å™¨
      removeTopicMonitor(topicName) {
        const monitor = this.monitoredTopics.get(topicName);
        if (monitor) {
          // å–æ¶ˆè®¢é˜…
          if (monitor.subscription) {
            monitor.subscription.unsubscribe();
          }
          
          // ç§»é™¤å¯è§†åŒ–å®¹å™¨
          if (monitor.container) {
            this.scene.removeChild(monitor.container);
          }
          
          // ç§»é™¤UI
          const drawerElement = document.getElementById(monitor.drawerId);
          if (drawerElement) {
            drawerElement.remove();
          }
          
          // ä»æ˜ å°„ä¸­ç§»é™¤
          this.monitoredTopics.delete(topicName);
          
          // æ›´æ–°ç›‘è§†å™¨æ•°é‡
          this.updateStatus('monitorCount', this.monitoredTopics.size.toString());
          
          this.logMessage(`å·²åœæ­¢ç›‘è§†è¯é¢˜: ${topicName}`, "info");
          this.showNotification(`å·²åœæ­¢ç›‘è§†è¯é¢˜: ${topicName}`, "info");
        }
      }
      
      // ç§»é™¤æ‰€æœ‰è¯é¢˜ç›‘è§†å™¨
      removeAllMonitoredTopics() {
        for (const [topicName] of this.monitoredTopics) {
          this.removeTopicMonitor(topicName);
        }
        this.monitoredTopics.clear();
        this.updateStatus('monitorCount', '0');
      }
      
      // é‡ç½®è§†å›¾
      resetView() {
        if (this.mapInfo.width > 0 && this.mapInfo.height > 0) {
          this.viewer.scaleToDimensions(this.mapInfo.width, this.mapInfo.height);
          this.viewer.shift(this.mapInfo.origin.x, this.mapInfo.origin.y);
          this.logMessage("è§†å›¾å·²é‡ç½®", "info");
        } else {
          this.showNotification("æ²¡æœ‰åœ°å›¾æ•°æ®ï¼Œæ— æ³•é‡ç½®è§†å›¾", "warning");
        }
      }
      
      // æˆªæ–­æ–‡æœ¬
      truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
      }
      
      // HTMLè½¬ä¹‰
      escapeHtml(text) {
        const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
      }
      
      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      updateStatus(elementId, text, className = '') {
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = text;
          element.className = 'status-value ' + className;
        }
      }
      
      // æ—¥å¿—æ¶ˆæ¯
      logMessage(message, type = "info") {
        const logContent = document.getElementById('logContent');
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `
          <span class="log-timestamp">[${timestamp}]</span>
          <span class="log-message">${message}</span>
        `;
        
        // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®é¢œè‰²
        if (type === "error") {
          entry.style.color = "#e74c3c";
        } else if (type === "success") {
          entry.style.color = "#2ecc71";
        } else if (type === "warning") {
          entry.style.color = "#f39c12";
        }
        
        logContent.insertBefore(entry, logContent.firstChild);
        
        // é™åˆ¶æ—¥å¿—æ•°é‡
        while (logContent.children.length > 50) {
          logContent.removeChild(logContent.lastChild);
        }
      }
      
      // æ˜¾ç¤ºé€šçŸ¥
      showNotification(message, type = "info") {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = 'notification';
        
        if (type === "error") {
          notification.classList.add('error');
        } else if (type === "warning") {
          notification.classList.add('warning');
        }
        
        notification.classList.add('show');
        
        // 3ç§’åè‡ªåŠ¨éšè—
        setTimeout(() => {
          notification.classList.remove('show');
        }, 3000);
      }
      
      // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
      initEventListeners() {
        // è¯é¢˜ç›‘è§†å™¨æŒ‰é’®
        document.getElementById('refreshTopicsBtn').addEventListener('click', () => {
          this.refreshTopicList();
        });
        
        document.getElementById('addTopicBtn').addEventListener('click', () => {
          this.addTopicMonitor();
        });
        
        // æ§åˆ¶é¢æ¿æ”¶èµ·/å±•å¼€
        document.getElementById('togglePanelBtn').addEventListener('click', () => {
          const controlPanel = document.getElementById('controlPanel');
          const toggleIcon = document.getElementById('toggleIcon');
          
          controlPanel.classList.toggle('collapsed');
          
          if (controlPanel.classList.contains('collapsed')) {
            toggleIcon.textContent = 'â–¶';
            this.logMessage("æ§åˆ¶é¢æ¿å·²æ”¶èµ·", "info");
          } else {
            toggleIcon.textContent = 'â—€';
            this.logMessage("æ§åˆ¶é¢æ¿å·²å±•å¼€", "info");
          }
          
          // è°ƒæ•´åœ°å›¾å¤§å°
          setTimeout(() => {
            if (this.viewer) {
              this.viewer.width = document.querySelector('.map-container').offsetWidth;
              this.viewer.height = document.querySelector('.map-container').offsetHeight;
              this.viewer.stage.canvas.width = this.viewer.width;
              this.viewer.stage.canvas.height = this.viewer.height;
            }
          }, 300);
        });
        
        // æ—¥å¿—é¢æ¿æ§åˆ¶
        document.getElementById('toggleLogBtn').addEventListener('click', () => {
          const logPanel = document.getElementById('logPanel');
          const toggleBtn = document.getElementById('toggleLogBtn');
          
          logPanel.classList.toggle('visible');
          
          if (logPanel.classList.contains('visible')) {
            toggleBtn.textContent = 'éšè—æ—¥å¿—';
            this.logMessage("æ—¥å¿—é¢æ¿å·²æ˜¾ç¤º", "info");
          } else {
            toggleBtn.textContent = 'æ˜¾ç¤ºæ—¥å¿—';
            this.logMessage("æ—¥å¿—é¢æ¿å·²éšè—", "info");
          }
        });
        
        // æ¸…ç©ºæ—¥å¿—
        document.getElementById('clearLogBtn').addEventListener('click', () => {
          document.getElementById('logContent').innerHTML = '';
          this.logMessage("æ—¥å¿—å·²æ¸…ç©º", "info");
        });
        
        // å…¨å±æ¨¡å¼
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
              this.logMessage(`å…¨å±æ¨¡å¼å¤±è´¥: ${err.message}`, "error");
            });
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }
        });
        
        // å¸®åŠ©é¢æ¿æ§åˆ¶
        let helpVisible = true;
        document.getElementById('toggleHelpBtn').addEventListener('click', () => {
          const helpPanel = document.querySelector('.help-panel');
          const toggleBtn = document.getElementById('toggleHelpBtn');
          
          if (helpVisible) {
            helpPanel.style.display = 'none';
            toggleBtn.textContent = 'æ˜¾ç¤ºæç¤º';
            this.logMessage("æ“ä½œæç¤ºå·²éšè—", "info");
          } else {
            helpPanel.style.display = 'block';
            toggleBtn.textContent = 'éšè—æç¤º';
            this.logMessage("æ“ä½œæç¤ºå·²æ˜¾ç¤º", "info");
          }
          
          helpVisible = !helpVisible;
        });
        
        // çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
          if (this.viewer) {
            this.viewer.width = document.querySelector('.map-container').offsetWidth;
            this.viewer.height = document.querySelector('.map-container').offsetHeight;
            this.viewer.stage.canvas.width = this.viewer.width;
            this.viewer.stage.canvas.height = this.viewer.height;
          }
        });
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
          switch (e.key.toLowerCase()) {
            case 'r':
              this.resetView();
              break;
            case 'p':
              document.getElementById('togglePanelBtn').click();
              break;
          }
        });
        
        // å…¨å±å˜åŒ–ç›‘å¬
        document.addEventListener('fullscreenchange', () => {
          const fullscreenBtn = document.getElementById('fullscreenBtn');
          if (document.fullscreenElement) {
            fullscreenBtn.textContent = 'â›¶';
            this.logMessage("å·²è¿›å…¥å…¨å±æ¨¡å¼", "info");
          } else {
            fullscreenBtn.textContent = 'â›¶';
            this.logMessage("å·²é€€å‡ºå…¨å±æ¨¡å¼", "info");
          }
        });
      }
    }
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åº”ç”¨
    window.addEventListener('DOMContentLoaded', () => {
      const app = new ROS2DMapViewer();
      window.ros2dApp = app; // æš´éœ²åˆ°å…¨å±€ä»¥ä¾¿è°ƒè¯•
      
      console.log('ROS2D åœ°å›¾æŸ¥çœ‹å™¨å·²åŠ è½½');
      console.log('å¯ç”¨å¿«æ·é”®:');
      console.log('  R - é‡ç½®è§†å›¾');
      console.log('  P - æ”¶èµ·/å±•å¼€æ§åˆ¶é¢æ¿');
    });
  </script>
</body>
</html>
