<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      background-color: #f5f5f5;
    }

    h1 {
      margin-bottom: 20px;
      color: #333;
    }

    .container {
      width: 90%;
      max-width: 1200px;
      text-align: center;
    }

    .control-panel {
      margin-bottom: 30px;
      padding: 20px;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    button {
      margin: 5px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background-color: #3498db;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #2980b9;
    }

    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }

    .status {
      margin: 15px 0;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }

    .connected {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .disconnected {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .camera-view {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-top: 20px;
    }

    .camera-view h2 {
      margin-top: 0;
      color: #333;
    }

    .camera-canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #ddd;
      border-radius: 5px;
      background-color: #000;
      max-width: 100%;
    }

    .image-info {
      margin-top: 15px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      text-align: left;
    }

    .stats {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      margin-top: 20px;
      gap: 10px;
    }

    .stat-item {
      background-color: #e9ecef;
      padding: 10px 20px;
      border-radius: 5px;
      min-width: 200px;
    }

    .stat-value {
      font-weight: bold;
      color: #3498db;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1.3.0/build/roslib.js"></script>
</head>

<body>
  <div class="container">
    <h1>ROS Depth Camera Viewer</h1>
    
    <div class="control-panel">
      <h2>ROS Connection</h2>
      <div id="connectionStatus" class="status disconnected">Disconnected from ROS</div>
      
      <div>
        <button id="connectBtn" onclick="connectToROS()">Connect to ROS</button>
        <button id="startCameraBtn" onclick="startCamera()" disabled>Start Camera</button>
        <button id="stopCameraBtn" onclick="stopCamera()" disabled>Stop Camera</button>
      </div>
      
      <div class="stats">
        <div class="stat-item">
          Camera Topic: <span class="stat-value" id="topicName">/camera/depth/image_raw</span>
        </div>
        <div class="stat-item">
          FPS: <span class="stat-value" id="fpsCounter">0</span>
        </div>
        <div class="stat-item">
          Frame Count: <span class="stat-value" id="frameCounter">0</span>
        </div>
      </div>
    </div>
    
    <div class="camera-view">
      <h2>Depth Camera Image</h2>
      <canvas id="depthCanvas" width="640" height="480" class="camera-canvas"></canvas>
      
      <div class="image-info">
        <div id="imageInfo">No image data received</div>
        <div id="depthInfo">Click on image to get depth value</div>
      </div>
    </div>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let ros = null;
    let subcam = null;
    let canvas, ctx;
    let isConnected = false;
    let isCameraRunning = false;
    let frameCount = 0;
    let fps = 0;
    let lastFpsTime = Date.now();
    
    // è¿æ¥ROS
    function connectToROS() {
      if (ros) {
        console.log('ROS connection already exists');
        return;
      }
      
      updateStatus('Connecting to ROS...', 'disconnected');
      document.getElementById('connectBtn').disabled = true;
      document.getElementById('connectBtn').textContent = 'Connecting...';
      
      // åˆ›å»ºROSè¿æ¥
      ros = new ROSLIB.Ros({
        url: 'ws://192.168.0.111:9090'
      });
      
      // è¿æ¥æˆåŠŸ
      ros.on('connection', () => {
        console.log('âœ… Connected to ROS Bridge');
        isConnected = true;
        updateStatus('Connected to ROS Bridge', 'connected');
        document.getElementById('connectBtn').textContent = 'Connected';
        document.getElementById('startCameraBtn').disabled = false;
        initializeCanvas();
      });
      
      // è¿æ¥é”™è¯¯
      ros.on('error', (error) => {
        console.error('âŒ ROS connection error:', error);
        updateStatus('Connection error: ' + error, 'disconnected');
        isConnected = false;
        document.getElementById('connectBtn').disabled = false;
        document.getElementById('connectBtn').textContent = 'Connect to ROS';
        disableCameraButtons();
      });
      
      // è¿æ¥å…³é—­
      ros.on('close', () => {
        console.log('ğŸ”Œ Disconnected from ROS');
        updateStatus('Disconnected from ROS', 'disconnected');
        isConnected = false;
        document.getElementById('connectBtn').disabled = false;
        document.getElementById('connectBtn').textContent = 'Connect to ROS';
        disableCameraButtons();
        stopCamera();
        ros = null;
      });
    }
    
    // åˆå§‹åŒ–ç”»å¸ƒ
    function initializeCanvas() {
      canvas = document.getElementById('depthCanvas');
      ctx = canvas.getContext('2d');
      
      // è®¾ç½®ç”»å¸ƒèƒŒæ™¯
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // æ·»åŠ ç‚¹å‡»äº‹ä»¶
      canvas.addEventListener('click', handleCanvasClick);
    }
    
    // å¯åŠ¨ç›¸æœº
    function startCamera() {
      if (!ros || !isConnected) {
        alert('Please connect to ROS first');
        return;
      }
      
      if (isCameraRunning) {
        console.log('Camera is already running');
        return;
      }
      
      console.log('Starting camera subscription...');
      
      // åœæ­¢ä¹‹å‰çš„è®¢é˜…
      stopCamera();
      
      // åˆ›å»ºè®¢é˜…è€…
      subcam = new ROSLIB.Topic({
        ros: ros,
        name: '/camera/depth/image_raw',
        messageType: 'sensor_msgs/msg/Image'
      });
      
      // è®¢é˜…æ¶ˆæ¯
      subcam.subscribe(handleImageMessage);
      
      isCameraRunning = true;
      document.getElementById('startCameraBtn').disabled = true;
      document.getElementById('stopCameraBtn').disabled = false;
      
      updateStatus('Camera started - waiting for images...', 'connected');
      console.log('âœ… Camera subscription started');
    }
    
    // åœæ­¢ç›¸æœº
    function stopCamera() {
      if (subcam) {
        subcam.unsubscribe();
        subcam = null;
        console.log('Camera subscription stopped');
      }
      
      isCameraRunning = false;
      document.getElementById('startCameraBtn').disabled = false;
      document.getElementById('stopCameraBtn').disabled = true;
      
      // æ¸…ç©ºç”»å¸ƒ
      if (ctx) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      updateImageInfo('Camera stopped');
    }
    
    // å¤„ç†å›¾åƒæ¶ˆæ¯
    function handleImageMessage(message) {
      try {
        // æ›´æ–°å¸§ç‡ç»Ÿè®¡
        frameCount++;
        const now = Date.now();
        if (now - lastFpsTime >= 1000) {
          fps = frameCount;
          frameCount = 0;
          lastFpsTime = now;
          updateStats();
        }
        
        // è§£æå›¾åƒæ•°æ®
        const width = message.width;
        const height = message.height;
        const encoding = message.encoding;
        const data = message.data;
        
        // æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§
        if (!width || !height || width === 0 || height === 0) {
          updateImageInfo('Invalid image dimensions');
          return;
        }
        
        // è°ƒæ•´ç”»å¸ƒå¤§å°
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
          console.log(`Canvas resized to ${width}x${height}`);
        }
        
        // å¤„ç†å›¾åƒ
        if (encoding === '16UC1' || encoding === '32FC1') {
          // æ·±åº¦å›¾åƒ
          processDepthImage(message, width, height);
        } else if (encoding === 'rgb8' || encoding === 'bgr8' || encoding === 'mono8') {
          // å½©è‰²æˆ–ç°åº¦å›¾åƒ
          processColorImage(message, width, height);
        } else {
          updateImageInfo(`Unsupported encoding: ${encoding}`);
          console.warn('Unsupported encoding:', encoding);
        }
        
      } catch (error) {
        console.error('Error processing image:', error);
        updateImageInfo('Error: ' + error.message);
      }
    }
    
    // å¤„ç†æ·±åº¦å›¾åƒ
    function processDepthImage(message, width, height) {
      const encoding = message.encoding;
      const data = message.data;
      
      try {
        // åˆ›å»ºå›¾åƒæ•°æ®
        const imageData = ctx.createImageData(width, height);
        
        let depthArray;
        if (encoding === '16UC1') {
          // 16ä½æ— ç¬¦å·æ•´æ•° (æ¯«ç±³)
          depthArray = new Uint16Array(data.buffer || data);
        } else if (encoding === '32FC1') {
          // 32ä½æµ®ç‚¹æ•° (ç±³)
          depthArray = new Float32Array(data.buffer || data);
        } else {
          return;
        }
        
        // æ‰¾åˆ°æ·±åº¦èŒƒå›´
        let minDepth = Infinity;
        let maxDepth = -Infinity;
        let validCount = 0;
        
        for (let i = 0; i < Math.min(depthArray.length, width * height); i++) {
          let depth = depthArray[i];
          if (encoding === '16UC1') depth /= 1000.0; // æ¯«ç±³è½¬ç±³
          
          if (depth > 0 && depth < 100) { // æœ‰æ•ˆæ·±åº¦å€¼
            minDepth = Math.min(minDepth, depth);
            maxDepth = Math.max(maxDepth, depth);
            validCount++;
          }
        }
        
        if (validCount === 0) {
          minDepth = 0;
          maxDepth = 5; // é»˜è®¤èŒƒå›´
        }
        
        const depthRange = maxDepth - minDepth;
        
        // å°†æ·±åº¦æ˜ å°„åˆ°ç°åº¦å›¾åƒ
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = y * width + x;
            if (i >= depthArray.length) break;
            
            let depth = depthArray[i];
            if (encoding === '16UC1') depth /= 1000.0;
            
            const pixelIndex = i * 4;
            
            if (depth === 0 || depth > 100) {
              // æ— æ•ˆæ·±åº¦ - é»‘è‰²
              imageData.data[pixelIndex] = 0;
              imageData.data[pixelIndex + 1] = 0;
              imageData.data[pixelIndex + 2] = 0;
            } else {
              // æœ‰æ•ˆæ·±åº¦ - ç°åº¦æ˜ å°„
              const normalized = Math.max(0, Math.min(1, (depth - minDepth) / depthRange));
              const intensity = Math.floor(normalized * 255);
              
              // ä½¿ç”¨çƒ­å›¾é¢œè‰²ï¼ˆè“->é’->ç»¿->é»„->çº¢ï¼‰
              let r, g, b;
              if (normalized < 0.25) {
                // è“è‰²åˆ°é’è‰²
                r = 0;
                g = Math.floor(normalized * 4 * 255);
                b = 255;
              } else if (normalized < 0.5) {
                // é’è‰²åˆ°ç»¿è‰²
                r = 0;
                g = 255;
                b = Math.floor((1 - (normalized - 0.25) * 4) * 255);
              } else if (normalized < 0.75) {
                // ç»¿è‰²åˆ°é»„è‰²
                r = Math.floor((normalized - 0.5) * 4 * 255);
                g = 255;
                b = 0;
              } else {
                // é»„è‰²åˆ°çº¢è‰²
                r = 255;
                g = Math.floor((1 - (normalized - 0.75) * 4) * 255);
                b = 0;
              }
              
              imageData.data[pixelIndex] = r;
              imageData.data[pixelIndex + 1] = g;
              imageData.data[pixelIndex + 2] = b;
            }
            imageData.data[pixelIndex + 3] = 255; // Alphaé€šé“
          }
        }
        
        // ç»˜åˆ¶å›¾åƒ
        ctx.putImageData(imageData, 0, 0);
        
        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        const info = `Size: ${width}x${height} | Encoding: ${encoding} | Range: ${minDepth.toFixed(2)}-${maxDepth.toFixed(2)}m | Valid pixels: ${validCount}`;
        updateImageInfo(info);
        
      } catch (error) {
        console.error('Error in processDepthImage:', error);
        updateImageInfo('Depth processing error: ' + error.message);
      }
    }
    
    // å¤„ç†å½©è‰²/ç°åº¦å›¾åƒ
    function processColorImage(message, width, height) {
      const encoding = message.encoding;
      const data = message.data;
      
      try {
        const imageData = ctx.createImageData(width, height);
        const dataArray = new Uint8Array(data.buffer || data);
        
        if (encoding === 'rgb8') {
          // RGBæ ¼å¼
          for (let i = 0; i < Math.min(dataArray.length, width * height * 3); i += 3) {
            const pixelIndex = Math.floor(i / 3) * 4;
            imageData.data[pixelIndex] = dataArray[i];     // R
            imageData.data[pixelIndex + 1] = dataArray[i + 1]; // G
            imageData.data[pixelIndex + 2] = dataArray[i + 2]; // B
            imageData.data[pixelIndex + 3] = 255; // Alpha
          }
        } else if (encoding === 'bgr8') {
          // BGRæ ¼å¼
          for (let i = 0; i < Math.min(dataArray.length, width * height * 3); i += 3) {
            const pixelIndex = Math.floor(i / 3) * 4;
            imageData.data[pixelIndex] = dataArray[i + 2];   // R
            imageData.data[pixelIndex + 1] = dataArray[i + 1]; // G
            imageData.data[pixelIndex + 2] = dataArray[i];   // B
            imageData.data[pixelIndex + 3] = 255; // Alpha
          }
        } else if (encoding === 'mono8') {
          // ç°åº¦æ ¼å¼
          for (let i = 0; i < Math.min(dataArray.length, width * height); i++) {
            const pixelIndex = i * 4;
            const value = dataArray[i];
            imageData.data[pixelIndex] = value;     // R
            imageData.data[pixelIndex + 1] = value; // G
            imageData.data[pixelIndex + 2] = value; // B
            imageData.data[pixelIndex + 3] = 255; // Alpha
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        updateImageInfo(`Size: ${width}x${height} | Encoding: ${encoding}`);
        
      } catch (error) {
        console.error('Error in processColorImage:', error);
        updateImageInfo('Color processing error: ' + error.message);
      }
    }
    
    // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
    function handleCanvasClick(event) {
      if (!ctx || !isCameraRunning) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((event.clientX - rect.left) * scaleX);
      const y = Math.floor((event.clientY - rect.top) * scaleY);
      
      // è·å–åƒç´ é¢œè‰²
      const pixelData = ctx.getImageData(x, y, 1, 1).data;
      
      document.getElementById('depthInfo').textContent = 
        `Clicked at (${x}, ${y}) | Color: RGB(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
    }
    
    // è¾…åŠ©å‡½æ•°
    function updateStatus(message, type) {
      const statusElement = document.getElementById('connectionStatus');
      statusElement.textContent = message;
      statusElement.className = `status ${type}`;
    }
    
    function updateImageInfo(info) {
      document.getElementById('imageInfo').textContent = info;
    }
    
    function updateStats() {
      document.getElementById('fpsCounter').textContent = fps;
      document.getElementById('frameCounter').textContent = frameCount;
    }
    
    function disableCameraButtons() {
      document.getElementById('startCameraBtn').disabled = true;
      document.getElementById('stopCameraBtn').disabled = true;
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    window.addEventListener('load', () => {
      console.log('Page loaded');
      updateStatus('Click "Connect to ROS" to start', 'disconnected');
    });
  </script>
</body>

</html>